//
// Generated file, do not edit! Created by nedtool 5.6 from critical/models/applications/server/FlowRequests.msg.
//

#ifndef __CRITICAL_FLOWREQUESTS_M_H
#define __CRITICAL_FLOWREQUESTS_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif


namespace critical {

class FlowRequestPacketBase;
class FlowRequestPacket;
class FlowResponsePacket;
class FlowFreePacket;
class FlowInterruptedPacket;
} // namespace critical

#include "inet/networklayer/contract/ipv6/Ipv6Address_m.h" // import inet.networklayer.contract.ipv6.Ipv6Address

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk


namespace critical {

/**
 * Enum generated from <tt>critical/models/applications/server/FlowRequests.msg:6</tt> by nedtool.
 * <pre>
 * enum FlowPacketType
 * {
 *     FLOW_REQUEST = 1;
 *     FLOW_RESPONSE = 2;
 *     FLOW_FREE = 3;
 *     FLOW_INTERRUPTED = 4;
 * }
 * </pre>
 */
enum FlowPacketType {
    FLOW_REQUEST = 1,
    FLOW_RESPONSE = 2,
    FLOW_FREE = 3,
    FLOW_INTERRUPTED = 4
};

/**
 * Class generated from <tt>critical/models/applications/server/FlowRequests.msg:13</tt> by nedtool.
 * <pre>
 * class FlowRequestPacketBase extends inet::FieldsChunk
 * {
 *     chunkLength = inet::B(1);
 * 
 *     inet::Ipv6Address source;
 *     inet::Ipv6Address destination;
 *     uint32_t label;
 * 
 *     FlowPacketType type = static_cast<FlowPacketType>(-1); // 1 byte
 * }
 * </pre>
 */
class FlowRequestPacketBase : public ::inet::FieldsChunk
{
  protected:
    inet::Ipv6Address source;
    inet::Ipv6Address destination;
    uint32_t label = 0;
    critical::FlowPacketType type = static_cast<FlowPacketType>(-1);

  private:
    void copy(const FlowRequestPacketBase& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowRequestPacketBase&);

  public:
    FlowRequestPacketBase();
    FlowRequestPacketBase(const FlowRequestPacketBase& other);
    virtual ~FlowRequestPacketBase();
    FlowRequestPacketBase& operator=(const FlowRequestPacketBase& other);
    virtual FlowRequestPacketBase *dup() const override {return new FlowRequestPacketBase(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const inet::Ipv6Address& getSource() const;
    virtual inet::Ipv6Address& getSourceForUpdate() { handleChange();return const_cast<inet::Ipv6Address&>(const_cast<FlowRequestPacketBase*>(this)->getSource());}
    virtual void setSource(const inet::Ipv6Address& source);
    virtual const inet::Ipv6Address& getDestination() const;
    virtual inet::Ipv6Address& getDestinationForUpdate() { handleChange();return const_cast<inet::Ipv6Address&>(const_cast<FlowRequestPacketBase*>(this)->getDestination());}
    virtual void setDestination(const inet::Ipv6Address& destination);
    virtual uint32_t getLabel() const;
    virtual void setLabel(uint32_t label);
    virtual critical::FlowPacketType getType() const;
    virtual void setType(critical::FlowPacketType type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowRequestPacketBase& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowRequestPacketBase& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>critical/models/applications/server/FlowRequests.msg:23</tt> by nedtool.
 * <pre>
 * class FlowRequestPacket extends FlowRequestPacketBase
 * {
 *     type = FLOW_REQUEST;
 * 
 *     uint64_t burst;                //  8B
 *     uint64_t bandwidth;            //  8B
 *     uint64_t delay;                //  8B
 * 
 *     chunkLength = inet::B(61);
 * }
 * </pre>
 */
class FlowRequestPacket : public ::critical::FlowRequestPacketBase
{
  protected:
    uint64_t burst = 0;
    uint64_t bandwidth = 0;
    uint64_t delay = 0;

  private:
    void copy(const FlowRequestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowRequestPacket&);

  public:
    FlowRequestPacket();
    FlowRequestPacket(const FlowRequestPacket& other);
    virtual ~FlowRequestPacket();
    FlowRequestPacket& operator=(const FlowRequestPacket& other);
    virtual FlowRequestPacket *dup() const override {return new FlowRequestPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint64_t getBurst() const;
    virtual void setBurst(uint64_t burst);
    virtual uint64_t getBandwidth() const;
    virtual void setBandwidth(uint64_t bandwidth);
    virtual uint64_t getDelay() const;
    virtual void setDelay(uint64_t delay);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowRequestPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>critical/models/applications/server/FlowRequests.msg:33</tt> by nedtool.
 * <pre>
 * class FlowResponsePacket extends FlowRequestPacketBase
 * {
 *     type = FLOW_RESPONSE;
 * 
 *     bool accepted;
 * 
 *     chunkLength = inet::B(38);
 * }
 * </pre>
 */
class FlowResponsePacket : public ::critical::FlowRequestPacketBase
{
  protected:
    bool accepted = false;

  private:
    void copy(const FlowResponsePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowResponsePacket&);

  public:
    FlowResponsePacket();
    FlowResponsePacket(const FlowResponsePacket& other);
    virtual ~FlowResponsePacket();
    FlowResponsePacket& operator=(const FlowResponsePacket& other);
    virtual FlowResponsePacket *dup() const override {return new FlowResponsePacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getAccepted() const;
    virtual void setAccepted(bool accepted);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowResponsePacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowResponsePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>critical/models/applications/server/FlowRequests.msg:41</tt> by nedtool.
 * <pre>
 * class FlowFreePacket extends FlowRequestPacketBase
 * {
 *     type = FLOW_FREE;
 * 
 *     chunkLength = inet::B(37);
 * }
 * </pre>
 */
class FlowFreePacket : public ::critical::FlowRequestPacketBase
{
  protected:

  private:
    void copy(const FlowFreePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowFreePacket&);

  public:
    FlowFreePacket();
    FlowFreePacket(const FlowFreePacket& other);
    virtual ~FlowFreePacket();
    FlowFreePacket& operator=(const FlowFreePacket& other);
    virtual FlowFreePacket *dup() const override {return new FlowFreePacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowFreePacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowFreePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>critical/models/applications/server/FlowRequests.msg:47</tt> by nedtool.
 * <pre>
 * class FlowInterruptedPacket extends FlowRequestPacketBase
 * {
 *     type = FLOW_INTERRUPTED;
 * 
 *     bool continued;
 * 
 *     chunkLength = inet::B(38);
 * }
 * </pre>
 */
class FlowInterruptedPacket : public ::critical::FlowRequestPacketBase
{
  protected:
    bool continued = false;

  private:
    void copy(const FlowInterruptedPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowInterruptedPacket&);

  public:
    FlowInterruptedPacket();
    FlowInterruptedPacket(const FlowInterruptedPacket& other);
    virtual ~FlowInterruptedPacket();
    FlowInterruptedPacket& operator=(const FlowInterruptedPacket& other);
    virtual FlowInterruptedPacket *dup() const override {return new FlowInterruptedPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getContinued() const;
    virtual void setContinued(bool continued);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowInterruptedPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowInterruptedPacket& obj) {obj.parsimUnpack(b);}

} // namespace critical

#endif // ifndef __CRITICAL_FLOWREQUESTS_M_H

